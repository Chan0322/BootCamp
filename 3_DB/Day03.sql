-- DAY 3 --

-- 숫자 데이터 함수

-- ABS() : 절대값 표현
SELECT ABS(10), ABS(-10)
FROM DUAL;

-- MOD() : 주어진 컬럼이나 값을 나눈 나머지를 반환
-- 몫을 확인하고 싶은 경우에는 그냥 나누면 된다.
SELECT MOD(10, 3), MOD(10, 6), (10/6)
FROM DUAL;

-- CEIL() : 소수점 첫째 자리에서 올림.
-- FLOOR() : 소수점 이하 숫자를 버림.
SELECT CEIL(123.456), CEIL(123.678), CEIL(123),
	   FLOOR(123.456), FLOOR(123.678), FLOOR(123)
FROM DUAL;

--TRUNC() : 지정한 위치에서부터 버림.
SELECT TRUNC(123.456, 0),
	   TRUNC(123.456, 1),
	   TRUNC(123.456, 2),
	   TRUNC(123.456, -2)
FROM DUAL;


-- EMPLOYEE 테이블에서
-- 입사한 달이 홀수 달인 사원들의
-- 사번, 사원명, 입사일 조회
SELECT EMP_ID 사번,
	   EMP_NAME 사원명,
	   HIRE_DATE 입사일
FROM EMPLOYEE	-- 19/03/25
WHERE MOD(SUBSTR(HIRE_DATE,5,1), 2) = 1;

-- MONTHS_BETWEEN() : 두 날짜 사이의 개월 수
SELECT EMP_NAME, HIRE_DATE,
TRUNC(MONTHS_BETWEEN(SYSDATE, HIRE_DATE))
FROM EMPLOYEE;

-- NEXT_DAY()
-- 앞으로 다가올 가장 가까운 요일을 반환
-- 1: 일요일 ~ 7: 토요일
SELECT NEXT_DAY(SYSDATE, '토요일'),
	   NEXT_DAY(SYSDATE, '일'),
	   NEXT_DAY(SYSDATE, 6),
--	   NEXT_DAY(SYSDATE, 'SATURDAY') 시스템 설정이 한글이므로 불가
FROM DUAL;

SELECT * FROM V$NLS_PARAMETERS;
-- 현재 설정된 정보를 테이블 형태로 보관 -> 이러한 테이블을 '데이터 사전(데이터 딕셔너리)

SELECT * FROM TABS;

-- LAST_DAY() : 마지막 일(DAY)을 조회
SELECT LAST_DAY(SYSDATE)
FROM DUAL;

SELECT (SYSDATE - 10),
	   (SYSDATE - TO_DATE('2022/03/01','RR/MM/DD')),
	   (SYSDATE + 30)
FROM DUAL;

SELECT HIRE_DATE, (HIRE_DATE + 10)
FROM EMPLOYEE;


--
SELECT SYSDATE,
	   TO_CHAR(SYSDATE, 'RR/MM/DD'),
	   TO_CHAR(SYSDATE, 'YYYY-MM-DD HH:MI:SS'),
	   TO_CHAR(SYSDATE, 'YEAR, Q')||'분기',
	   TO_CHAR(SYSDATE, 'MON, YYYY')
FROM DUAL;

-- 연도
-- Y/R
SELECT TO_CHAR(TO_DATE('190325','YYMMDD'), 'YYYY') "결과1",
	   TO_CHAR(TO_DATE('190325','RRMMDD'), 'RRRR') "결과2",
	   TO_CHAR(TO_DATE('800325','YYMMDD'), 'YYYY') "결과3",
	   TO_CHAR(TO_DATE('800325','RRMMDD'), 'RRRR') "결과4"
FROM DUAL;

SELECT TO_DATE('800325','RRMMDD'), TO_DATE('800325','YYMMDD')
FROM DUAL;

-- 4자리 한번에 입력 받는 경우는 문제X
-- 2자리 입력 받을 경우
-- YY => 현 세기 기준으로 값을 추가
-- RR => 반 세기

-- RR
-- 50~99 -> 1900년대
-- 00~49 -> 2000년대

-- YY
-- 80 -> 2080


-- SELECT 문의 실행 순서
/*
-- 5: SELECT 컬럼 AS 별칭, 계산식, 함수
-- 1: FROM 테이블명
-- 2: WHERE 조건
-- 3: GROUP BY 그룹을 묶을 컬럼명
-- 4: HAVING 그룹에 대한 조건식, 함수식
-- 6: ORDER BY 컬럼|별칭|순서 [ASC|DESC][, 컬럼명.....]
*/


-- ORDER BY
SELECT EMP_ID, EMP_NAME 이름, SALARY, DEPT_CODE
FROM EMPLOYEE
--ORDER BY EMP_ID;
--ORDER BY 이름 DESC;
--ORDER BY 3 DESC;
ORDER BY 4 DESC, EMP_NAME;

-- GROUP BY --

--부서별 평균 급여

-- 전체 사원의 급여 평균
SELECT TRUNC(AVG(SALARY), -3)
FROM EMPLOYEE;

-- D1의 평균
SELECT TRUNC(AVG(SALARY), -3)
FROM EMPLOYEE
WHERE DEPT_CODE = 'D6';


-- GROUP BY 절 --
-- 특정 컬럼, 계산식을 기준으로
-- 그룹별로 묶어 한 테이블 내에서 소그룹별로 조회하고자 할 때 선언하는 구문.
SELECT DEPT_CODE, TRUNC(AVG(SALARY), -3)
FROM EMPLOYEE
GROUP BY DEPT_CODE;


-- 부서 별 총인원, 급여 합계, 급여 평균, 최대 급여, 최소 급여
-- 단, 부서코드 기준으로 오름차순
-- 급여평균은 100의 자리까지만 처리하고 나머지는 버림처리하여 확인
SELECT DEPT_CODE,
	   COUNT(*) 총인원,
	   SUM(SALARY) 급여합계,
	   TRUNC(AVG(SALARY),-3) 급여평균,
	   MAX(SALARY) 최대급여,
	   MIN(SALARY) 최소급여
FROM EMPLOYEE
GROUP BY DEPT_CODE 
ORDER BY 1;


-- 직급 코드 별 보너스 받는 사원의 수 조회
SELECT JOB_CODE, COUNT(BONUS)
FROM EMPLOYEE
GROUP BY JOB_CODE
ORDER BY 1;

-- GROUP BY 에서 주어진 컬럼 뿐만이 아니라 함수식도 사용 가능.
SELECT DECODE(SUBSTR(EMP_NO,8,1), 2, '여성', '남성'), COUNT(*)
FROM EMPLOYEE
GROUP BY SUBSTR(EMP_NO,8,1);


-- 부서별 급여 평균을 구해서 조회
-- 단, 부서별 급여 평균이 300만원 이상인 부서만 조회
SELECT DEPT_CODE, AVG(SALARY) 평균
FROM EMPLOYEE
WHERE SALARY > 3000000
GROUP BY DEPT_CODE;

-- HAVING : GROUP BY 한 각 소그룹에 대한 조건을 설정.
SELECT DEPT_CODE, AVG(SALARY) 평균
FROM EMPLOYEE
GROUP BY DEPT_CODE
HAVING AVG(SALARY) > 3000000;


-- 부서별 그룹의 급여 합계 중 900만원 초과하는 부서의
-- 코드와 급여합을 조회.
SELECT DEPT_CODE, SUM(SALARY) 급여합
FROM EMPLOYEE
GROUP BY DEPT_CODE
HAVING SUM(SALARY) > 9000000;


-- 1) 급여 합계가 가장 높은 부서를 찾고,
-- 2) 해당 부서의 부서 코드와 급여 합계를 조회.

-- 1) 급여 합이 가장 높은 부서의 급여 합 탐색
SELECT MAX(SUM(SALARY))
FROM EMPLOYEE
GROUP BY DEPT_CODE;
-- 17700000
-- 2) 해당 부서의 부서 코드와 급여 합계를 조회
SELECT DEPT_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE
HAVING SUM(SALARY) = 17700000;

--- Sub Query --
SELECT DEPT_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE
HAVING SUM(SALARY) = (SELECT MAX(SUM(SALARY))
					  FROM EMPLOYEE
					  GROUP BY DEPT_CODE);


--
SELECT DEPT_CODE, JOB_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE, JOB_CODE
ORDER BY 1, 2;

SELECT DEPT_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE
ORDER BY 1;

SELECT EMP_NAME, DEPT_CODE, JOB_CODE FROM EMPLOYEE
ORDER BY DEPT_CODE, JOB_CODE;


-- 집계 함수 --
-- ROLLUP : 특정 그룹으로 묶은 뒤, 해당 그룹에 대한 집계(총 합계)를 산출하는 함수
SELECT DEPT_CODE, JOB_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY ROLLUP(DEPT_CODE, JOB_CODE)
ORDER BY 1, 2;


-- SET OPERATOR
-- 두개 이상의 SELECT 한 결과를
-- 합치거나, 합칠 때 중복을 제거 와 같은
-- 집합 형태의 결과로 조회하는 명령어


-- 합집합
-- UNION : 두개 이상의 SELECT 한 결과(ResultSet)를 구하는 명령어
--		   만약 중복이 있을 경우, 중복되는 결과는 1번만 보여준다.
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
UNION
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY>3000000;

-- UNION ALL : UNION과 동일. 단, 중복이 있어도 그대로 조회
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
UNION ALL
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY>3000000;

-- 교집합
-- INTERSECT : 중복되는 결과만 보여준다.
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
INTERSECT
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY>3000000;

-- 차집합
-- MINUS : 가장 첫 결과에서 나머지 결과들과 일치하는 내용을 뺀, 고유 결과를 조회.
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE = 'D5'
MINUS
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY>3000000;


-- [JOIN] --
-- 두 개 이상의 테이블을 하나로 합쳐 조회하는 데 사용하는 명령 구문

-- 'J6'라는 직급을 가진 사원들의 정보를 조회하는데....
--  근무 부서명이 궁금하다.....
SELECT EMP_NAME, JOB_CODE, DEPT_CODE
FROM EMPLOYEE
WHERE JOB_CODE = 'J6';

SELECT * FROM DEPARTMENT
WHERE DEPT_ID IN('D1', 'D8');

-- 오라클 전용 문법
-- FROM 절에 ,로 구분하며 합치게 될 테이블을 나열
-- 테이블을 엮는 기준으로 WHERE 조건을 명시한다.
SELECT EMP_NAME, JOB_CODE, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE, DEPARTMENT
WHERE DEPT_CODE = DEPT_ID;

-- 표준 문법
-- FROM 다음에 JOIN 테이블명 ON() || USING() 구문 사용.
SELECT EMP_NAME, JOB_CODE, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE
JOIN DEPARTMENT ON(EMPLOYEE.DEPT_CODE = DEPARTMENT.DEPT_ID);

SELECT * FROM EMPLOYEE;


-- 두 개의 테이블에서 공통 컬럼의 이름이 같은 경우
-- EMPLOYEE테이블과 JOB 테이블 JOIN
SELECT * FROM EMPLOYEE;
SELECT * FROM JOB;

-- 오라클 전용 문법
SELECT EMP_ID, EMP_NAME, EMPLOYEE.JOB_CODE, JOB_NAME
FROM EMPLOYEE, JOB
WHERE EMPLOYEE.JOB_CODE = JOB.JOB_CODE;    -- JOB_CODE가 어느 테이블의 JOB_CODE인지 헷갈리므로 명시를 해줘야 함.

-- 테이블에 별칭을 붙여 더 간단히 작성 가능.
SELECT EMP_ID, EMP_NAME, E.JOB_CODE, JOB_NAME
FROM EMPLOYEE E, JOB J
WHERE E.JOB_CODE = J.JOB_CODE;


-- 표준 문법
SELECT EMP_ID, EMP_NAME, JOB.JOB_CODE, JOB_NAME
FROM EMPLOYEE
JOIN JOB ON(EMPLOYEE.JOB_CODE = JOB.JOB_CODE);

SELECT EMP_ID, EMP_NAME, J.JOB_CODE, JOB_NAME
FROM EMPLOYEE E
JOIN JOB J ON(E.JOB_CODE = J.JOB_CODE);

SELECT EMP_ID, EMP_NAME, JOB_CODE, JOB_NAME
FROM EMPLOYEE
JOIN JOB USING(JOB_CODE);      -- 공통 컬럼의 경우 USING을 통해서도 작성 가능하다.

SELECT *
FROM EMPLOYEE
JOIN JOB USING(JOB_CODE);


-- 사번, 사원명, 급여 등급(SAL_GRADE), 등급 기준 최소급여, 최대급여 조회.
-- EMPLOYEE 테이블
-- SAL_GRADE 테이블

-- 두 테이블 정보 조회(공통컬럼)
SELECT * FROM EMPLOYEE;
SELECT * FROM SAL_GRADE;

-- 표준 문법
SELECT EMP_ID 사번, EMP_NAME 사원명, SAL_LEVEL 급여등급, MIN_SAL 최소급여, MAX_SAL 최대급여
FROM EMPLOYEE
JOIN SAL_GRADE USING(SAL_LEVEL);


-- DEPARTMENT의 위치 정보와
-- LOCATION을 조인하여
-- 각 부서별 근무지 위치를 조회.
-- 부서코드, 부서명, 근무지코드, 근무지 위치
SELECT * FROM DEPARTMENT; --LOCATION_ID
SELECT * FROM LOCATION;   -- LOCAL_CODE

SELECT DEPT_ID 부서코드, DEPT_TITLE 부서명, LOCATION_ID 근무지코드, LOCAL_NAME 근무지위치
FROM DEPARTMENT
JOIN LOCATION ON (LOCATION_ID = LOCAL_CODE);


-- INNER JOIN / OUTER JOIN
-- INNER JOIN : 둘 모두 일치하는 데이터만 합친다.
-- OUTER JOIN : 둘 모두, 둘 중 하나가 가진 데이터 합친다.

-- INNER JOIN
SELECT DISTINCT DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE
JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID);

SELECT DISTINCT DEPT_CODE
FROM EMPLOYEE;

-- OUTER JOIN
-- LEFT JOIN : 두 테이블 중 원본(왼쪽) 테이블의 정보를 모두 포함하여 조회.
-- RIGHT JOIN : 두 테이블 중 JOIN에 명시된 테이블의 정보를 모두 포함하여 조회.
-- FULL JOIN : 두 테이블이 가진 데이터 중 서로가 가지지 않은 값일지라도 모두 포함하여 조회.


-- INNER
SELECT DEPT_CODE, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE=DEPT_ID);

-- LEFT
SELECT DEPT_CODE, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE
LEFT JOIN DEPARTMENT ON (DEPT_ID=DEPT_CODE);

-- ORACLE 문법
SELECT DEPT_CODE, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE, DEPARTMENT
WHERE DEPT_CODE = DEPT_ID(+);

SELECT *
FROM EMPLOYEE
LEFT JOIN DEPARTMENT ON (DEPT_ID=DEPT_CODE);


-- RIGHT JOIN
SELECT DEPT_CODE, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE
RIGHT JOIN DEPARTMENT ON(DEPT_ID=DEPT_CODE);

SELECT *
FROM EMPLOYEE
RIGHT JOIN DEPARTMENT ON(DEPT_ID=DEPT_CODE);

-- ORACLE 문법
SELECT DEPT_CODE, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE, DEPARTMENT
WHERE DEPT_CODE(+) = DEPT_ID;


-- FULL JOIN
SELECT DEPT_CODE, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE
FULL JOIN DEPARTMENT ON (DEPT_CODE=DEPT_ID);

-- ORACLE 구문에서는 FULL OUTER JOIN 지원안한다.
SELECT DEPT_CODE, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE, DEPARTMENT
WHERE DEPT_CODE(+) = DEPT_ID(+);


-- 추가적인 종류의 JOIN
-- 기본적인 JOIN은 양 테이블 정보에서 하나씩은 일치하는 정보를 가지고 JOIN 수행. EQ(EQUAL) JOIN
-- 하지만, 서로 같은 값을 가지지 않은 테이블의 정보를 조회 할 경우 CROSS JOIN을 통해 JOIN 수행 가능.   => 모든 ROW들 끼리 한번 씩 다 곱해짐.

SELECT * FROM EMPLOYEE;
SELECT * FROM NATIONAL;

SELECT *
FROM EMPLOYEE
CROSS JOIN NATIONAL
ORDER BY 1;


-- NON-EQ JOIN
-- 특정 범위 내에 존재하는 조건으로 JOIN 수행.

-- ON() 안에 계산식, 함수식 ... 다양하게 작성이 가능하다.
SELECT EMP_NAME, DEPT_CODE, SALARY, EMPLOYEE.SAL_LEVEL
FROM EMPLOYEE
JOIN SAL_GRADE ON(SALARY BETWEEN MIN_SAL AND MAX_SAL);


-- SELF JOIN
-- 자기 자신을 JOIN하는 방법.

-- 직원의 정보와 그 직원을 관리하는 매니저의 정보 조회
-- 같은 테이블을 조인하므로, 반드시 컬럼이 어느 테이블의 것인지 구분!
SELECT E.EMP_ID "사번",
	   E.EMP_NAME "사원명",
	   E.MANAGER_ID "관리자 사번",
	   M.EMP_NAME "관리자명"
FROM EMPLOYEE E
JOIN EMPLOYEE M ON(E.MANAGER_ID = M.EMP_ID);



-- 다중 JOIN
-- 여러개의 테이블을 JOIN
-- JOIN시 순서에 주의해서 작성해야 한다.

SELECT *
FROM EMPLOYEE
JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID)
JOIN LOCATION ON(LOCATION_ID = LOCAL_CODE);

SELECT EMP_NAME, DEPT_TITLE, LOCAL_NAME
FROM EMPLOYEE
JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID)
JOIN LOCATION ON(LOCATION_ID = LOCAL_CODE);

-- ORACLE 구문
SELECT EMP_NAME, DEPT_TITLE, LOCAL_NAME
FROM EMPLOYEE, DEPARTMENT, LOCATION
WHERE DEPT_CODE = DEPT_ID
  AND LOCATION_ID = LOCAL_CODE;

-- [문제1]
-- 한국(KO)과 일본(JP)에 근무하는 직원들의 정보 조회.
-- 사원명, 부서명, 지역명, 국가명
-- EMPLOYEE, NATIONAL, LOCATION, DEPARTMENT

SELECT * FROM EMPLOYEE;
SELECT * FROM NATIONAL;
SELECT * FROM LOCATION;
SELECT * FROM DEPARTMENT;

SELECT EMP_NAME, DEPT_TITLE, LOCAL_NAME, NATIONAL_NAME
FROM EMPLOYEE
JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID)
JOIN LOCATION ON(LOCATION_ID = LOCAL_CODE)
JOIN NATIONAL USING(NATIONAL_CODE)
WHERE NATIONAL_NAME IN('한국', '일본');


-- [문제2]
-- 직급이 대리이면서, 아시아지역에서 근무하는 사원 조회
-- 사번, 사원명, 직급명, 부서명, 근무지역명, 급여
SELECT * FROM EMPLOYEE;
SELECT * FROM JOB;
SELECT * FROM DEPARTMENT;
SELECT * FROM LOCATION;

SELECT EMP_ID 사번, EMP_NAME 사원명, JOB_NAME 직급명, DEPT_TITLE 부서명, LOCAL_NAME 근무지역명, SALARY 급여
FROM EMPLOYEE
JOIN JOB USING(JOB_CODE)
JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID)
JOIN LOCATION ON(LOCAL_CODE = LOCATION_ID);

SELECT EMP_ID 사번, EMP_NAME 사원명, JOB_NAME 직급명, DEPT_TITLE 부서명, LOCAL_NAME 근무지역명, SALARY 급여
FROM EMPLOYEE
JOIN JOB USING(JOB_CODE)
JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID)
JOIN LOCATION ON(LOCAL_CODE = LOCATION_ID)
WHERE JOB_NAME='대리'
  AND LOCAL_NAME IN('ASIA1', 'ASIA2', 'ASIA3');

-- 강사님 풀이
SELECT EMP_ID, EMP_NAME, JOB_NAME, DEPT_TITLE, LOCAL_NAME, SALARY
FROM EMPLOYEE E
JOIN JOB J ON(E.JOB_CODE = J.JOB_CODE )
JOIN DEPARTMENT ON(DEPT_CODE=DEPT_ID )
JOIN LOCATION ON(LOCATION_ID = LOCAL_CODE)
WHERE JOB_NAME='대리'
  AND LOCAL_NAME LIKE 'ASIA%';

-- 또다른 방법
SELECT EMP_ID, EMP_NAME, JOB_NAME, DEPT_TITLE, LOCAL_NAME, SALARY
FROM EMPLOYEE E
JOIN JOB J ON(E.JOB_CODE = J.JOB_CODE AND JOB_NAME='대리')
JOIN DEPARTMENT ON(DEPT_CODE=DEPT_ID )
JOIN LOCATION ON(LOCATION_ID = LOCAL_CODE AND LOCAL_NAME LIKE 'ASIA%');


-- ORACLE 구문
SELECT EMP_ID, EMP_NAME, JOB_NAME, DEPT_TITLE, LOCAL_NAME, SALARY
FROM EMPLOYEE E, JOB J, DEPARTMENT D, LOCATION L
WHERE E.JOB_CODE = J.JOB_CODE
  AND E.DEPT_CODE = D.DEPT_ID
  AND LOCATION_ID = LOCAL_CODE
  AND JOB_NAME = '대리'
  AND LOCAL_NAME LIKE 'ASIA%';    -- 순서 바뀌어도 상관 없이 잘 실행된다. 그러나 보통 JOIN 하는 순서대로 적는게 일반적.
  
  
  
-- SUBQUERY
-- 서브쿼리